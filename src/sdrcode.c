/*------------------------------------------------------------------------------
* sdrcode.c : GNSS code generation functions
*
* Copyright (C) 2014 Taro Suzuki <gnsssdrlib@gmail.com>
*-----------------------------------------------------------------------------*/
#include "measurement_engine.h"

/* code chip length (chip) */
#define LEN_L1CA        1023        /* GPS L1C/A */
#define LEN_L1CP        10230       /* GPS L1C Pilot */
#define LEN_L1CD        10230       /* GPS L1C Data */
#define LEN_L1CO        1800        /* GPS L1C overlay */
#define LEN_G1G2        511         /* GLONASS G1/G2 */
#define LEN_NH10        10          /* 10 bit Neuman-Hoffman code */
#define LEN_NH20        20          /* 20 bit Neuman-Hoffman code */
/* code chip rate (chip/s) */
#define CRATE_L1CA      1.023E6     /* GPS L1C/A */
#define CRATE_L1CP      1.023E6     /* GPS L1C Pilot */
#define CRATE_L1CD      1.023E6     /* GPS L1C Data */
#define CRATE_L1CO      100         /* GPS L1C overlay */
#define CRATE_G1G2      0.511E6     /* GLONASS G1/G2 */
#define CRATE_NH10      1000        /* 10 bit Neuman-Hoffman code */
#define CRATE_NH20      500         /* 20 bit Neuman-Hoffman code */

/* global variables ----------------------------------------------------------*/
static char legendre[10223]={0};

/* flip array direction ------------------------------------------------------*/
void fliparrays(short *in, int n, short *out)
{
    int i;
    short *tmp;
    tmp=(short *)malloc(n*sizeof(short));
    if (tmp!=NULL) {
        memcpy(tmp,in,n);
        for(i=0;i<n;i++) out[n-i-1]=tmp[i];
        free(tmp);
    }
}
/* flip array direction ------------------------------------------------------*/
void fliparrayc(char *in, int n, char *out)
{
    int i;
    char *tmp;
    tmp=(char *)malloc(n);
    if (tmp!=NULL) {
        memcpy(tmp,in,n);
        for(i=0;i<n;i++) out[n-i-1]=tmp[i];
        free(tmp);
    }
}
/* octal to binary -----------------------------------------------------------*/
void oct2bin(const char *oct, int n, int nbit, char *bin, int skiplast,
             int flip)
{
    int i,j,k,skip;
    const static char octlist[8][3]={{ 1,1,1},{ 1,1,-1},{ 1,-1,1},{ 1,-1,-1},
                                     {-1,1,1},{-1,1,-1},{-1,-1,1},{-1,-1,-1}};
    skip=3*n-nbit;
    for (i=j=0;i<n;i++) {
        for (k=0;k<3;k++) {
            if (!skiplast&&i==0&&k<skip) continue;
            if (skiplast&&i==n-1&&k>=3-skip) continue;
            bin[j]=octlist[oct[i]-'0'][k];
            j++;
        }
    }
    if (flip) fliparrayc(bin,nbit,bin);
}
/* hexadecimal to decimal ----------------------------------------------------*/
int hexc2dec(char hex)
{
    if ('0'<=hex&&'9'>=hex) return (hex-'0');
    if ('A'<=hex&&'F'>=hex) return (hex+10-'A');
    if ('a'<=hex&&'f'>=hex) return (hex+10-'a');
    return 0;
}
/* hexadecimal to binary -----------------------------------------------------*/
void hex2bin(const char *hex, int n, int nbit, short *bin, int skiplast,
             int flip)
{
    int i,j,k,skip;
    const static char hexlist[16][4]=
        {{ 1, 1,1,1},{ 1, 1,1,-1},{ 1, 1,-1,1},{ 1, 1,-1,-1},
         { 1,-1,1,1},{ 1,-1,1,-1},{ 1,-1,-1,1},{ 1,-1,-1,-1},
         {-1, 1,1,1},{-1, 1,1,-1},{-1, 1,-1,1},{-1, 1,-1,-1},
         {-1,-1,1,1},{-1,-1,1,-1},{-1,-1,-1,1},{-1,-1,-1,-1}};
    
    skip=4*n-nbit;
    for (i=j=0;i<n;i++) {
        for (k=0;k<4;k++) {
            if (!skiplast&&i==0&&k<skip) continue;
            if (skiplast&&i==n-1&&k>=4-skip) continue;
            bin[j]=hexlist[hexc2dec(hex[i])][k];
            j++;
        }
    }
    if (flip) fliparrays(bin,nbit,bin);
}
/* C/A code (IS-GPS-200) -----------------------------------------------------*/
static short *gencode_L1CA(int prn, int *len, double *crate)
{
    const static short delay[]={ /* G2 delay (chips) */
           5,   6,   7,   8,  17,  18, 139, 140, 141, 251,   /*   1- 10 */
         252, 254, 255, 256, 257, 258, 469, 470, 471, 472,   /*  11- 20 */
         473, 474, 509, 512, 513, 514, 515, 516, 859, 860,   /*  21- 30 */
         861, 862, 863, 950, 947, 948, 950,  67, 103,  91,   /*  31- 40 */
          19, 679, 225, 625, 946, 638, 161,1001, 554, 280,   /*  41- 50 */
         710, 709, 775, 864, 558, 220, 397,  55, 898, 759,   /*  51- 60 */
         367, 299,1018, 729, 695, 780, 801, 788, 732,  34,   /*  61- 70 */
         320, 327, 389, 407, 525, 405, 221, 761, 260, 326,   /*  71- 80 */
         955, 653, 699, 422, 188, 438, 959, 539, 879, 677,   /*  81- 90 */
         586, 153, 792, 814, 446, 264,1015, 278, 536, 819,   /*  91-100 */
         156, 957, 159, 712, 885, 461, 248, 713, 126, 807,   /* 101-110 */
         279, 122, 197, 693, 632, 771, 467, 647, 203, 145,   /* 111-120 */
         175,  52,  21, 237, 235, 886, 657, 634, 762, 355,   /* 121-130 */
        1012, 176, 603, 130, 359, 595,  68, 386, 797, 456,   /* 131-140 */
         499, 883, 307, 127, 211, 121, 118, 163, 628, 853,   /* 141-150 */
         484, 289, 811, 202,1021, 463, 568, 904, 670, 230,   /* 151-160 */
         911, 684, 309, 644, 932,  12, 314, 891, 212, 185,   /* 161-170 */
         675, 503, 150, 395, 345, 846, 798, 992, 357, 995,   /* 171-180 */
         877, 112, 144, 476, 193, 109, 445, 291,  87, 399,   /* 181-190 */
         292, 901, 339, 208, 711, 189, 263, 537, 663, 942,   /* 191-200 */
         173, 900,  30, 500, 935, 556, 373,  85, 652, 310    /* 201-210 */
    };
    char G1[LEN_L1CA],G2[LEN_L1CA],R1[10],R2[10],C1,C2;
    short *code;
    int i,j;

    if (prn<1||MAXGPSSATNO<prn||
        !(code=(short *)malloc(sizeof(short)*LEN_L1CA))) {
        return NULL;
    }
    for (i=0;i<10;i++) R1[i]=R2[i]=-1;
    for (i=0;i<LEN_L1CA;i++) {
        G1[i]=R1[9];
        G2[i]=R2[9];
        C1=R1[2]*R1[9];
        C2=R2[1]*R2[2]*R2[5]*R2[7]*R2[8]*R2[9];
        for (j=9;j>0;j--) {
            R1[j]=R1[j-1];
            R2[j]=R2[j-1];
        }
        R1[0]=C1;
        R2[0]=C2;
    }
    for (i=0,j=LEN_L1CA-delay[prn-1];i<LEN_L1CA;i++,j++) {
        code[i]=-G1[i]*G2[j%LEN_L1CA];
    }
    *len=LEN_L1CA;
    *crate=CRATE_L1CA;

    return code;
}
/*  Legendre Sequence for L1C Code -------------------------------------------*/
void gen_legendre_sequence()
{
    int i;
    for (i=0;i<10223;i++)
        legendre[i]=1;

    for(i=0;i<10224;i++)
        legendre[(i*i)%10223]=-1;
    legendre[0]=1;
}
/* L1CP code (IS-GPS-800) ----------------------------------------------------*/
static short *gencode_L1CP(int prn, int *len, double *crate)
{
    const static short weil[]={ /* Weil Index */
       5111, 5109, 5108, 5106, 5103, 5101, 5100, 5098, 5095, 5094, /*   1- 10 */
       5093, 5091, 5090, 5081, 5080, 5069, 5068, 5054, 5044, 5027, /*  11- 20 */
       5026, 5014, 5004, 4980, 4915, 4909, 4893, 4885, 4832, 4824, /*  21- 30 */
       4591, 3706, 5092, 4986, 4965, 4920, 4917, 4858, 4847, 4790, /*  31- 40 */
       4770, 4318, 4126, 3961, 3790, 4911, 4881, 4827, 4795, 4789, /*  41- 50 */
       4725, 4675, 4539, 4535, 4458, 4197, 4096, 3484, 3481, 3393, /*  51- 60 */
       3175, 2360, 1852, 5065, 5063, 5055, 5012, 4981, 4952, 4934, /*  61- 70 */
       4932, 4786, 4762, 4640, 4601, 4563, 4388, 3820, 3687, 5052, /*  71- 80 */
       5051, 5047, 5039, 5015, 5005, 4984, 4975, 4974, 4972, 4962, /*  81- 90 */
       4913, 4907, 4903, 4833, 4778, 4721, 4661, 4660, 4655, 4623, /*  91-100 */
       4590, 4548, 4461, 4442, 4347, 4259, 4256, 4166, 4155, 4109, /* 101-110 */
       4100, 4023, 3998, 3979, 3903, 3568, 5088, 5050, 5020, 4990, /* 111-120 */
       4982, 4966, 4949, 4947, 4937, 4935, 4906, 4901, 4872, 4865, /* 121-130 */
       4863, 4818, 4785, 4781, 4776, 4775, 4754, 4696, 4690, 4658, /* 131-140 */
       4607, 4599, 4596, 4530, 4524, 4451, 4441, 4396, 4340, 4335, /* 141-150 */
       4296, 4267, 4168, 4149, 4097, 4061, 3989, 3966, 3789, 3775, /* 151-160 */
       3622, 3523, 3515, 3492, 3345, 3235, 3169, 3157, 3082, 3072, /* 161-170 */
       3032, 3030, 4582, 4595, 4068, 4871, 4514, 4439, 4122, 4948, /* 171-180 */
       4774, 3923, 3411, 4745, 4195, 4897, 3047, 4185, 4354, 5077, /* 181-190 */
       4042, 2111, 4311, 5024, 4352, 4678, 5034, 5085, 3646, 4868, /* 191-200 */
       3668, 4211, 2883, 2850, 2815, 2542, 2492, 2376, 2036, 1920  /* 201-210 */
    };

    const static short insert[]={ /* Insertion Index */
        412,  161,    1,  303,  207, 4971, 4496,    5, 4557,  485, /*   1- 10 */
        253, 4676,    1,   66, 4485,  282,  193, 5211,  729, 4848, /*  11- 20 */
        982, 5955, 9805,  670,  464,   29,  429,  394,  616, 9457, /*  21- 30 */
       4429, 4771,  365, 9705, 9489, 4193, 9947,  824,  864,  347, /*  31- 40 */
        677, 6544, 6312, 9804,  278, 9461,  444, 4839, 4144, 9875, /*  41- 50 */
        197, 1156, 4674,10035, 4504,    5, 9937,  430,    5,  355, /*  51- 60 */
        909, 1622, 6284, 9429,   77,  932, 5973,  377,10000,  951, /*  61- 70 */
       6212,  686, 9352, 5999, 9912, 9620,  635, 4951, 5453, 4658, /*  71- 80 */
       4800,   59,  318,  571,  565, 9947, 4654,  148, 3929,  293, /*  81- 90 */
        178,10142, 9683,  137,  565,   35, 5949,    2, 5982,  825, /*  91-100 */
       9614, 9790, 5613,  764,  660, 4870, 4950, 4881, 1151, 9977, /* 101-110 */
       5122,10074, 4832,   77, 4698, 1002, 5549, 9606, 9228,  604, /* 111-120 */
       4678, 4854, 4122, 9471, 5026,  272, 1027,  317,  691,  509, /* 121-130 */
       9708, 5033, 9938, 4314,10140, 4790, 9823, 6093,  469, 1215, /* 131-140 */
        799,  756, 9994, 4843, 5271, 9661, 6255, 5203,  203,10070, /* 141-150 */
         30,  103, 5692,   32, 9826,   76,   59, 6831,  958, 1471, /* 151-160 */
      10070,  553, 5487,   55,  208,  645, 5268, 1873,  427,  367, /* 161-170 */
       1404, 5652,    5,  368,  451, 9595, 1030, 1324,  692, 9819, /* 171-180 */
       4520, 9911,  278,  642, 6330, 5508, 1872, 5445,10131,  422, /* 181-190 */
       4918,  787, 9864, 9753, 9859,  328,    1, 4733,  164,  135, /* 191-200 */
        174,  132,  538,  176,  198,  595,  574,  321,  596,  491  /* 201-210 */
    };

    char weilcode[10223];
    short *code;
    int i,j,ind,w=weil[prn-1],p=insert[prn-1]-1;
    const static char insertbit[7]={-1,1,1,-1,1,-1,-1};

    if (prn<1||MAXGPSSATNO<prn||
        !(code=(short *)malloc(sizeof(short)*LEN_L1CP))) {
        return NULL;
    }
    /* Generate Legendre Sequence */
    if (!legendre[0]) gen_legendre_sequence();

    for (i=0;i<10223;i++) {
        ind=(i+w)%10223;
        weilcode[i]=-legendre[i]*legendre[ind];
    }
    /* Insert bits */
    for (i=0;i<p;i++) code[i]=weilcode[i];
    for (j=0;j<7;j++) code[i++]=insertbit[j];
    for (i=p+7;i<LEN_L1CP;i++) code[i]=weilcode[i-7];
    *len=LEN_L1CP;
    *crate=CRATE_L1CP;

    return code;
}
/* L1CD code (IS-GPS-800) ----------------------------------------------------*/
static short *gencode_L1CD(int prn, int *len, double *crate)
{
    const static short weil[]={ /* Weil Index */
       5097, 5110, 5079, 4403, 4121, 5043, 5042, 5104, 4940, 5035, /*   1- 10 */
       4372, 5064, 5084, 5048, 4950, 5019, 5076, 3736, 4993, 5060, /*  11- 20 */
       5061, 5096, 4983, 4783, 4991, 4815, 4443, 4769, 4879, 4894, /*  21- 30 */
       4985, 5056, 4921, 5036, 4812, 4838, 4855, 4904, 4753, 4483, /*  31- 40 */
       4942, 4813, 4957, 4618, 4669, 4969, 5031, 5038, 4740, 4073, /*  41- 50 */
       4843, 4979, 4867, 4964, 5025, 4579, 4390, 4763, 4612, 4784, /*  51- 60 */
       3716, 4703, 4851, 4955, 5018, 4642, 4840, 4961, 4263, 5011, /*  61- 70 */
       4922, 4317, 3636, 4884, 5041, 4912, 4504, 4617, 4633, 4566, /*  71- 80 */
       4702, 4758, 4860, 3962, 4882, 4467, 4730, 4910, 4684, 4908, /*  81- 90 */
       4759, 4880, 4095, 4971, 4873, 4561, 4588, 4773, 4997, 4583, /*  91-100 */
       4900, 4574, 4629, 4676, 4181, 5057, 4944, 4401, 4586, 4699, /* 101-110 */
       3676, 4387, 4866, 4926, 4657, 4477, 4359, 4673, 4258, 4447, /* 111-120 */
       4570, 4486, 4362, 4481, 4322, 4668, 3967, 4374, 4553, 4641, /* 121-130 */
       4215, 3853, 4787, 4266, 4199, 4545, 4208, 4485, 3714, 4407, /* 131-140 */
       4182, 4203, 3788, 4471, 4691, 4281, 4410, 3953, 3465, 4801, /* 141-150 */
       4278, 4546, 3779, 4115, 4193, 3372, 3786, 3491, 3812, 3594, /* 151-160 */
       4028, 3652, 4224, 4334, 3245, 3921, 3840, 3514, 2922, 4227, /* 161-170 */
       3376, 3560, 4989, 4756, 4624, 4446, 4174, 4551, 3972, 4399, /* 171-180 */
       4562, 3133, 4157, 5053, 4536, 5067, 3905, 3721, 3787, 4674, /* 181-190 */
       3436, 2673, 4834, 4456, 4056, 3804, 3672, 4205, 3348, 4152, /* 191-200 */
       3883, 3473, 3669, 3455, 2318, 2945, 2947, 3220, 4052, 2953  /* 201-210 */
    };
    const static short insert[]={ /* Insertion Index */
        181,  359,   72, 1110, 1480, 5034, 4622,    1, 4547,  826, /*   1- 10 */
       6284, 4195,  368,    1, 4796,  523,  151,  713, 9850, 5734, /*  11- 20 */
         34, 6142,  190,  644,  467, 5384,  801,  594, 4450, 9437, /*  21- 30 */
       4307, 5906,  378, 9448, 9432, 5849, 5547, 9546, 9132,  403, /*  31- 40 */
       3766,    3,  684, 9711,  333, 6124,10216, 4251, 9893, 9884, /*  41- 50 */
       4627, 4449, 9798,  985, 4272,  126,10024,  434, 1029,  561, /*  51- 60 */
        289,  638, 4353, 9899, 4629,  669, 4378, 4528, 9718, 5485, /*  61- 70 */
       6222,  672, 1275, 6083, 5264,10167, 1085,  194, 5012, 4938, /*  71- 80 */
       9356, 5057,  866,    2,  204, 9808, 4365,  162,  367,  201, /*  81- 90 */
         18,  251,10167,   21,  685,   92, 1057,    3, 5756,   14, /*  91-100 */
       9979, 9569,  515,  753, 1181, 9442,  669, 4834,  541, 9933, /* 101-110 */
       6683, 4828, 9710,10170, 9629,  260,   86, 5544,  923,  257, /* 111-120 */
        507, 4572, 4491,  341,  130,   79, 1142,  448,  875,  555, /* 121-130 */
       1272, 5198, 9529, 4459,10019, 9353, 9780,  375,  503, 4507, /* 131-140 */
        875, 1246,    1, 4534,    8, 9549, 6240,   22, 5652,10069, /* 141-150 */
       4796, 4980,   27,   90, 9788,  715, 9720,  301, 5450, 5215, /* 151-160 */
         13, 1147, 4855, 1190, 1267, 1302,    1, 5007,  549,  368, /* 161-170 */
       6300, 5658, 4302,  851, 4353, 9618, 9652, 1232,  109,10174, /* 171-180 */
       6178, 1851, 1299,  325,10206, 9968,10191, 5438,10080,  219, /* 181-190 */
        758, 2140, 9753, 4799,10126,  241, 1245, 1274, 1456, 9967, /* 191-200 */
        235,  512, 1078, 1078,  953, 5647,  669, 1311, 5827,   15  /* 201-210 */
    };
    char weilcode[10224];
    short *code;
    int i,j,ind,w=weil[prn-1],p=insert[prn-1]-1;
    const static char insertbit[7]={-1,1,1,-1,1,-1,-1};

    if (prn<1||MAXGPSSATNO<prn||
        !(code=(short *)malloc(sizeof(short)*LEN_L1CD))) {
        return NULL;
    }
    /* Generate Legendre Sequence */
    if (!legendre[0]) gen_legendre_sequence();

    for (i=0;i<10223;i++) {
        ind=(i+w)%10223;
        weilcode[i]=-legendre[i]*legendre[ind];
    }
    /* Insert bits */
    for (i=0;i<p;i++) code[i]=weilcode[i];
    for (j=0;j<7;j++) code[i++]=insertbit[j];
    for (i=p+7;i<LEN_L1CP;i++) code[i]=weilcode[i-7];
    *len=LEN_L1CD;
    *crate=CRATE_L1CD;

    return code;
}
/* L1CO code (IS-GPS-800) ----------------------------------------------------*/
static short *gencode_L1CO(int prn, int *len, double *crate)
{
    const static char s1poly[210][5]={ /* S1 Polynomial Coefficient (Octal) */
        "5111","5421","5501","5403","6417","6141","6351","6501","6205","6235", /*   1- 10 */
        "7751","6623","6733","7627","5667","5051","7665","6325","4365","4745", /*  11- 20 */
        "7633","6747","4475","4225","7063","4423","6651","4161","7237","4473", /*  21- 30 */
        "5477","6163","7223","6323","7125","7035","4341","4353","4107","5735", /*  31- 40 */
        "6741","7071","4563","5755","6127","4671","4511","4533","5357","5607", /*  41- 50 */
        "6673","6153","7565","7107","6211","4321","7201","4451","5411","5141", /*  51- 60 */
        "7041","6637","4577","5111","5111","5111","5111","5111","5111","5111", /*  61- 70 */
        "5111","5111","5111","5111","5111","5111","5111","5111","5111","5111", /*  71- 80 */
        "5111","5111","5111","5111","5111","5111","5111","5111","5111","5111", /*  81- 90 */
        "5111","5111","5111","5111","5111","5111","5111","5111","5111","5421", /*  91-100 */
        "5421","5421","5421","5421","5421","5421","5421","5421","5421","5421", /* 101-110 */
        "5421","5421","5421","5421","5421","5421","5421","5421","5421","5421", /* 111-120 */
        "5421","5421","5421","5421","5421","5421","5421","5421","5421","5421", /* 121-130 */
        "5421","5421","5421","5421","5421","5421","5421","5421","5403","5403", /* 131-140 */
        "5403","5403","5403","5403","5403","5403","5403","5403","5403","5403", /* 141-150 */
        "5403","5403","5403","5403","5403","5403","5403","5403","5403","5403", /* 151-160 */
        "5403","5403","5403","5403","5403","5403","5403","5403","5403","5403", /* 161-170 */
        "5403","5403","5403","5403","5403","5403","5403","5403","5403","5403", /* 171-180 */
        "5403","5403","5403","5403","5403","5403","5403","5403","5403","5403", /* 181-190 */
        "5403","5403","5403","5403","5403","5403","5403","6501","6501","6501", /* 191-200 */
        "6501","6501","6501","6501","6501","6501","6501","6501","6501","6501"  /* 201-210 */
    };
    const static char s1init[210][5]={ /* S1 Initial Condition (Octal) */
        "3266","2040","1527","3307","3756","3026","0562","0420","3415","0337", /*   1- 10 */
        "0265","1230","2204","1440","2412","3516","2761","3750","2701","1206", /*  11- 20 */
        "1544","1774","0546","2213","3707","2051","3650","1777","3203","1762", /*  21- 30 */
        "2100","0571","3710","3535","3110","1426","0255","0321","3124","0572", /*  31- 40 */
        "1736","3306","1307","3763","1604","1021","2624","0406","0114","0077", /*  41- 50 */
        "3477","1000","3460","2607","2057","3467","0706","2032","1464","0520", /*  51- 60 */
        "1766","3270","0341","1740","3664","1427","2627","0701","3460","1373", /*  61- 70 */
        "2540","2004","2274","1340","0602","2502","0327","2600","0464","3674", /*  71- 80 */
        "3040","1153","0747","1770","3772","1731","1672","1333","2705","2713", /*  81- 90 */
        "3562","3245","3770","3202","3521","3250","2117","0530","3021","2511", /*  91-100 */
        "1562","1067","0424","3402","1326","2142","0733","0504","1611","2724", /* 101-110 */
        "0753","3724","2652","1743","0013","3464","2300","1334","2175","2564", /* 111-120 */
        "3075","3455","3627","0617","1324","3506","2231","1110","1271","3740", /* 121-130 */
        "3652","1644","3635","3436","3076","0434","3340","0054","2446","0025", /* 131-140 */
        "0150","2746","2723","2601","3440","1312","0544","2062","0176","3616", /* 141-150 */
        "1740","3777","0432","2466","1667","3601","2706","2022","1363","2331", /* 151-160 */
        "3556","2205","3734","2115","0010","2140","3136","0272","3264","2017", /* 161-170 */
        "2505","3532","0647","1542","2154","3734","2621","2711","0217","3503", /* 171-180 */
        "3457","3750","2525","0113","0265","1711","0552","0675","1706","3513", /* 181-190 */
        "1135","0566","0500","0254","3445","2542","1257","0211","0534","1420", /* 191-200 */
        "3401","0714","0613","2475","2572","3265","1250","1711","2704","0135"  /* 201-210 */
    };
    const static char s2init[210][5]={ /* S2 Initial Condition (Octal) */
        "0000","0000","0000","0000","0000","0000","0000","0000","0000","0000", /*   1- 10 */
        "0000","0000","0000","0000","0000","0000","0000","0000","0000","0000", /*  11- 20 */
        "0000","0000","0000","0000","0000","0000","0000","0000","0000","0000", /*  21- 30 */
        "0000","0000","0000","0000","0000","0000","0000","0000","0000","0000", /*  31- 40 */
        "0000","0000","0000","0000","0000","0000","0000","0000","0000","0000", /*  41- 50 */
        "0000","0000","0000","0000","0000","0000","0000","0000","0000","0000", /*  51- 60 */
        "0000","0000","0000","3035","1557","0237","2527","3307","1402","1225", /*  61- 70 */
        "0607","0351","3724","1675","2625","1030","1443","3277","1132","0572", /*  71- 80 */
        "1241","0535","1366","0041","0561","0122","1205","3753","2543","3031", /*  81- 90 */
        "2260","3773","3156","2215","0146","2413","2564","3310","2267","3120", /*  91-100 */
        "0064","1042","0476","1020","0431","0216","2736","2527","2431","1013", /* 101-110 */
        "0524","0726","1042","3362","1364","3354","0623","0145","0214","0223", /* 111-120 */
        "0151","2405","2522","3235","0452","2617","1300","1430","0773","0772", /* 121-130 */
        "3561","0607","0420","0527","3770","2536","2233","3366","3766","3554", /* 131-140 */
        "2060","2070","0713","3366","3247","2776","1244","2102","1712","1245", /* 141-150 */
        "3344","1277","0165","2131","3623","0141","0421","3032","2065","3024", /* 151-160 */
        "2663","2274","2114","1664","0413","1512","0135","2737","1015","1075", /* 161-170 */
        "1255","3473","2716","0101","1105","1407","3407","1046","3237","0154", /* 171-180 */
        "3010","2245","2051","2144","1743","2511","3410","1414","1275","2257", /* 181-190 */
        "2331","0276","3261","1760","0430","3477","1676","1636","2411","1473", /* 191-200 */
        "2266","2104","2070","1766","0711","2533","0353","1744","0053","2222"  /* 201-210 */
    };
    char S1[LEN_L1CO],S2[LEN_L1CO],T1[11],T2[11],R1[11],R2[11],C1,C2;
    short *code;
    int i,j;

    if (prn<1||MAXGPSSATNO<prn||
        !(code=(short *)malloc(sizeof(short)*LEN_L1CO))) {
        return NULL;
    }
    oct2bin(s1init[prn-1],4,11,R1,0,1); /* S1 Initial Condition */
    oct2bin(s2init[prn-1],4,11,R2,0,1); /* S2 Initial Condition (prn>=64) */
    oct2bin(s1poly[prn-1],4,11,T1,1,1); /* S1 Polynomial Coefficient */
    oct2bin("5001",4,11,T2,1,1); /* S2 Polynomial Coefficient (Constant) */
    T1[10]=T2[10]=-1; /* last tap is always 1 */

    for (i=0;i<LEN_L1CO;i++) {
        S1[i]=R1[10];
        S2[i]=R2[10];
        for (C1=C2=1,j=0;j<11;j++) {
            if (T1[j]==-1) C1*=R1[j];
            if (T2[j]==-1) C2*=R2[j];
        }
        for (j=10;j>0;j--) {
            R1[j]=R1[j-1];
            R2[j]=R2[j-1];
        }
        R1[0]=C1; R2[0]=C2; 

        if (prn>=64)
            code[i]=-S1[i]*S2[i];
        else
            code[i]=-S1[i];
    }
    *len=LEN_L1CO;
    *crate=CRATE_L1CO;

    return code;
}
/* GLONASS C/A code (GLONASS ICD) --------------------------------------------*/
static short *gencode_G1G2(int *len, double *crate)
{
    short *code;
    char C,R[9]={-1,-1,-1,-1,-1,-1,-1,-1,-1};
    int i,j;
    if (!(code=(short *)malloc(sizeof(short)*LEN_G1G2))) {
        return NULL;
    }
    for (i=0;i<LEN_G1G2;i++) {
        code[i]=-R[6];
        C=R[4]*R[8];
        for (j=8;j>0;j--) R[j]=R[j-1];
        R[0]=C;
    }
    *len=LEN_G1G2;
    *crate=CRATE_G1G2;

    return code;
}

/* Neuman-Hoffman code (10bit) -----------------------------------------------*/
static short *gencode_NH10(int *len, double *crate)
{
    short *code;

    if (!(code=(short *)calloc(LEN_NH10,sizeof(short)))) {
        return NULL;
    }
    code[0]=-1; code[1]=-1; code[2]=-1; code[3]=-1; code[4]= 1;
    code[5]= 1; code[6]=-1; code[7]= 1; code[8]=-1; code[9]= 1;

    if (len) *len=LEN_NH10;
    if (crate) *crate=CRATE_NH10;

    return code;
}
/* Neuman-Hoffman code (20bit) -----------------------------------------------*/
static short *gencode_NH20(int *len, double *crate)
{
    short *code;

    if (!(code=(short *)calloc(LEN_NH20,sizeof(short)))) {
        return NULL;
    }
    code[ 0]=-1; code[ 1]=-1; code[ 2]=-1; code[ 3]=-1; code[ 4]=-1;
    code[ 5]= 1; code[ 6]=-1; code[ 7]=-1; code[ 8]= 1; code[ 9]= 1;
    code[10]=-1; code[11]= 1; code[12]=-1; code[13]= 1; code[14]=-1;
    code[15]=-1; code[16]= 1; code[17]= 1; code[18]= 1; code[19]=-1;

    if (len) *len=LEN_NH20;
    if (crate) *crate=CRATE_NH20;

    return code;
}
/* binary offset carrier (BOC) -------------------------------------------------
* BOC modulation function
* args   : short  *cide     I   GNSS code (-1 or 1)
*          int    *len      I/O code length
*          double *crate    I/O code chip rate (chip/s)
*          int    m         I   sub-carrier frequency/1.023MHz
*          int    n         I   chip frequency/1.023MHz
* return : short*               BOC modulated code
*-----------------------------------------------------------------------------*/
static short *boc(short *code, int *len, double *crate, int m, int n)
{
    short *boccode;
    int i,j,N=2*m/n;

    if (!(boccode=(short *)calloc(N*(*len),sizeof(short)))) {
        return NULL;
    }

    for (i=0;i<(*len);i++) {
        for (j=0;j<N;j++) {
            boccode[N*i+j]=code[i];
        }
    }
    /* mix sub carrier */
    for (i=0;i<N*(*len)/2;i++) {
        boccode[2*i]=-boccode[2*i];
    }

    /* new code length and rate */
    (*len)*=N;
    (*crate)*=N;

    free(code);
    return boccode;
}
/* generate code ---------------------------------------------------------------
* generate code
* args   : int    prn       I   satellite PRN
*          int    ctype     I   code type (CTYPE_***)
*          int    *code     O   code length
*          double *crate    O   code chip rate (chip/s)
* return : short*               pointer of generated code
*-----------------------------------------------------------------------------*/
extern short *gencode(int prn, int ctype, int *len, double *crate)
{
    switch (ctype) {
    case CTYPE_L1CA  : return gencode_L1CA(prn,len,crate);
    /* using BOC(1,1) alternative for TMBOC(6,1,11) */
    case CTYPE_L1CP  : return boc(gencode_L1CP(prn,len,crate),len,crate,1,1);
    /* using BOC(1,1) alternative for TMBOC(6,1,11) */
    case CTYPE_L1CD  : return boc(gencode_L1CD(prn,len,crate),len,crate,1,1);
    case CTYPE_L1CO  : return gencode_L1CO(prn,len,crate);
    case CTYPE_G1    : return gencode_G1G2(len,crate);
    case CTYPE_G2    : return gencode_G1G2(len,crate);
    case CTYPE_L1SBAS: return gencode_L1CA(prn,len,crate);
    case CTYPE_NH10  : return gencode_NH10(len,crate);
    case CTYPE_NH20  : return gencode_NH20(len,crate);
    default          : 
        debug_print("error: gencode prn:%d ctype:%d",prn,ctype);
        return NULL;
    }
}
